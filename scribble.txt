2024-02-14 | how table-vis-switch worked (portals)


...in app/components/sidebar.tsx

        <div id="table-or-viz"></div>

...in app/(protected)/repos/repos.tsx:

import TableVisSwitch from "@/components/table-vis-switch";
import RepoVis from "./repo-vis";
import { createPortal } from "react-dom";

^^^

  const [tableVizElement, setTableVizElement] = React.useState<HTMLElement>();
  const [showTable, setShowTable] = React.useState<boolean>(true);

  // because "document" may not exist in nextjs client for some reason...
  React.useEffect(() => {
    const tve: HTMLElement = document.getElementById("table-or-viz")!;
    if (tve) {
      setTableVizElement(tve);
    }
  });

^^^
  return (
    <div>
      {/* {tableVizElement &&
        createPortal(
          <TableVisSwitch onToggle={handleToggle} />,
          tableVizElement
        )} */}

^^^
      {showTable ? (
        <RepoTable repos={repos} setValue={form.setValue} />
      ) : (
        <RepoVis repos={repos} />
      )} */}



^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

function getValueByKey(jsonArray: string, searchKey: string): number | null {
  const parsedArray: JsonObject[] = JSON.parse(jsonArray);

  const resultObject = parsedArray.find((item) => searchKey in item);

  if (resultObject) {
    return resultObject[searchKey];
  }

  return null; // or any default value if the key is not found
}

const expandInventoryToColumns = (inventory: JsonObject[]) => {
  inventory.forEach((i) => {
    for (const [key, val] of Object.entries(i)) {
      console.log(key, "--------", val);
    }
  });
};


npx shadcn-ui@latest add textarea


npx supabase gen types typescript --project-id mjmxxfikiuvjfjljbhcy --schema public > lib/sb_types.ts


// 2024-01-18 | just use constant in purr_utils, no need for this complexity
// export async function fetchGeoTypes(
//   supabase: SupabaseClient
// ): Promise<string[]> {
//   const { data, error } = await supabase.rpc("get_geo_type_values");
//   if (error) {
//     console.error(error);
//     return [];
//   } else {
//     return data;
//   }
// }

// export async function fetchBatches(supabase: SupabaseClient): Promise<Batch[]> {
//   const { data, error } = await supabase
//     .from("batch")
//     .select()
//     .order("row_created", { ascending: false });
//   if (error) {
//     console.error(error);
//     return [];
//   } else {
//     return data as Batch[];
//   }
// }


--select distinct(search_id), search_body from search_result order by search_id desc limit 5 ;

--select search_body from search_result;

--select id from profile; -- bc8a5974-b757-4b9b-80d6-e80f1da49084

--select * from profile;

--insert

CREATE OR REPLACE FUNCTION update_profile_search_history(user_id TEXT) RETURNS VOID AS $$
DECLARE
    searchHistory JSONB;
BEGIN
    -- Select distinct search_ids and corresponding search_body from search_result table
    SELECT jsonb_object_agg(search_id, search_body) INTO searchHistory
    FROM (
        SELECT DISTINCT search_id, jsonb_build_object(
            'tag', sr.search_body->>'tag',
            'term', sr.search_body->>'term',
            'assets', (sr.search_body->'assets')::JSONB,
            'suites', (sr.search_body->'suites')::JSONB,
            'search_id', sr.search_id
        ) AS search_body
        FROM search_result sr
        ORDER BY sr.search_id DESC
        LIMIT 5
    ) AS subquery;

    -- Update or insert into profile table
    UPDATE profile
    SET search_history = searchHistory
    WHERE id = user_id::UUID;
    
    IF NOT FOUND THEN
        -- If no row was updated, insert a new row
        INSERT INTO profile(id, search_history)
        VALUES (user_id::UUID, searchHistory);
    END IF;
    
    RETURN;
END;
$$ LANGUAGE plpgsql;